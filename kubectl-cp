#!/usr/bin/env python3
# pylint: disable=invalid-name
# -*- coding: utf-8 -*-
"""
---
name: kubectl-cp
description: An easy way to copy files from/to containers running on Kubernetes
website: https://github.com/marcio-pessoa/kubectl-cp
"""

import argparse
from enum import Enum
import os
import shlex
import sys
import subprocess


class Direction(Enum):
    """ File transfer direction type

    Args:
        Enum (int): File transfer direction type
    """
    unknown = 0
    download = 1
    upload = 2
    invalid = 5


class FileSystem(Enum):
    """ File system object type

    Args:
        Enum (int): File system object type
    """
    unknown = 0
    file = 1
    directory = 2
    hard_link = 3
    symbolic_link = 4


class Main():
    """ Main class """

    __version__ = '0.2.1-83'
    __date__ = '2024-03-27'

    def __init__(self):
        self.__verbose = False
        self.__container: str = None
        self.__src_path: str = None
        self.__dst_path: str = None
        self.__src_basepath: str = None

        parser = argparse.ArgumentParser(
            prog='kubectl-cp',
            description=(
                'An easy way to copy files from/to containers running on '
                'Kubernetes'
            ),
            formatter_class=argparse.RawDescriptionHelpFormatter,
            add_help=True,
            epilog=(
                'examples:\n'
                '  kubectl-cp -a "pod/example" container:/tmp/file .\n'
                '  kubectl-cp -a "deploy/example" -r container:/dir .\n'
                '  kubectl-cp -a "pod/example" file container:/tmp\n'
                '  kubectl-cp -a "-n test pod/example" -r dir container:/dir\n'
                '\n'
                'Copyleft (â†„) 2023-2024 Marcio Pessoa\n'
                'License: GPLv3\n'
                'Website: https://github.com/marcio-pessoa/kubectl-cp\n'
                'Contact: Marcio Pessoa <marcio.pessoa@gmail.com>\n'
            ),
        )
        parser.add_argument(
            'src_path',
            help='Source path')
        parser.add_argument(
            'dst_path',
            help='Destination path')
        parser.add_argument(
            '-a', '--arguments',
            help='kubectl arguments'
        )
        parser.add_argument(
            '-r', '--recursive',
            help='Recursively copy directories',
            action='store_true'
        )
        parser.add_argument(
            '-v', '--verbose',
            help='Enable verbose output',
            action='store_true'
        )
        parser.add_argument(
            '-V', '--version',
            action='version',
            help='show version information and exit',
            version=(
                f'kubectl-cp {self.__version__} {self.__date__}'
            ),
        )

        args = parser.parse_args()
        self.__verbose = args.verbose

        direction = _detect_direction(args.src_path, args.dst_path)
        self._set_direction_env(direction, args.src_path, args.dst_path)

        self._verbose(f'direction: {direction.name}')
        self._verbose(f'container: {self.__container}')
        self._verbose(f'source: {self.__src_path}')
        self._verbose(f'destination: {self.__dst_path}')
        self._verbose(f'arguments: {args.arguments}')

        result = 1
        if direction == Direction.download and not args.recursive:
            result = self.from_container_to_localhost(
                self.__container, self.__src_path, self.__dst_path,
                args.arguments
            )
        elif direction == Direction.upload and not args.recursive:
            result = self.from_localhost_to_container(
                self.__container, self.__src_path, self.__dst_path,
                args.arguments
            )
        elif direction == Direction.download and args.recursive:
            self.__src_basepath = os.path.basename(self.__src_path)
            result = self.from_container_directory_to_localhost(
                self.__container, self.__src_path, self.__dst_path,
                args.arguments
            )
        elif direction == Direction.upload and args.recursive:
            result = self.from_localhost_directory_to_container(
                self.__container, self.__src_path, self.__dst_path,
                args.arguments
            )
        else:
            print('Invalid input.')

        sys.exit(result)

    def _verbose(self, message):
        if self.__verbose:
            print(message)

    def _set_direction_env(self, direction, src_path, dst_path):
        if direction == Direction.download:
            self.__container = _split_container_and_file(src_path)[0]
            self.__src_path = _split_container_and_file(src_path)[1]
            self.__dst_path = dst_path
        elif direction == Direction.upload:
            self.__container = _split_container_and_file(dst_path)[0]
            self.__src_path = src_path
            self.__dst_path = _split_container_and_file(dst_path)[1]

    def from_container_to_localhost(self, container: str,
                                    src_path: str, dst_path: str,
                                    kubectl_args: str) -> bool:
        """ Copy a file from container to localhost

        Args:
            container (str): Container name
            src_path (str): Source file
            dst_path (str): Destination file
            kubectl_args (str): kubectl arguments

        Returns:
            bool: False on OK
        """
        if not self.__check_remote_path(container, src_path, kubectl_args):
            return True

        self._verbose(f'Copying {src_path}...')

        if dst_path == '.':
            dst_path = os.path.basename(src_path)

        cmd = (f'{_kubectl_path()} exec -i {kubectl_args} '
               f'-c {container} '
               f'-- cat {src_path}')
        self._verbose(f'  Command: {cmd}')

        file_type = FileSystem.unknown
        try:
            result = subprocess.run(shlex.split(cmd),
                                    check=True, capture_output=True)
            file_type = FileSystem.file
        except subprocess.CalledProcessError:
            file_type = FileSystem.directory

        if file_type == FileSystem.file:
            return _save_file(dst_path, result.stdout)
        if file_type == FileSystem.directory:
            self._verbose(f'  Creating directory {dst_path}...')
            return _create_directory(dst_path)

        return True

    def from_localhost_to_container(self, container: str,
                                    src_path: str, dst_path: str,
                                    kubectl_args: str) -> bool:
        """ Copy a file from localhost to container

        Args:
            container (str): Container name
            src_path (str): Source file
            dst_path (str): Destination file
            kubectl_args (str): kubectl arguments

        Returns:
            bool: False on OK
        """
        content = _read_file(src_path)
        if not content:
            print(f'{src_path}: file not found.')
            return True

        cmd = (f'{_kubectl_path()} exec '
               f'-i {kubectl_args} '
               f'-c {container} '
               f'-- sh -c "tee {dst_path} > /dev/null"')
        self._verbose(f'  Command: {cmd}')

        result = subprocess.run(shlex.split(cmd), input=content,
                                check=False, capture_output=False)

        return result.returncode

    def from_container_directory_to_localhost(self, container: str,
                                              src_dir: str, dst_dir: str,
                                              kubectl_args: str) -> bool:
        """ Copy a directory and contents from container to localhost

        Args:
            container (str): Container name
            src_dir (str): Source directory
            dst_dir (str): Destination directory
            kubectl_args (str): kubectl arguments

        Returns:
            bool: False on OK
        """
        if not self.__check_remote_path(container, src_dir, kubectl_args):
            return True

        self._verbose('Fetching file list...')
        cmd = (f'{_kubectl_path()} exec -i {kubectl_args} '
               f'-c {container} '
               f'-- sh -c "ls -1dR {src_dir}/*"')
        self._verbose(f'  Command: {cmd}')
        try:
            result = subprocess.run(shlex.split(cmd),
                                    check=True, capture_output=True)
        except subprocess.CalledProcessError:
            print('  Failed to read directory')
            return True

        files = result.stdout.decode().split("\n")
        files.insert(0, src_dir)
        files = [x for x in files if x != '']

        for src_path in files:
            dst_path = os.path.join(
                dst_dir,
                src_path[src_path.index(self.__src_basepath):]
            )
            if self.from_container_to_localhost(
                    container, src_path, dst_path, kubectl_args):
                return True

        return False

    def from_localhost_directory_to_container(self, container: str,
                                              src_dir: str, dst_dir: str,
                                              kubectl_args: str) -> bool:
        """ Copy a directory and contents from localhost to container

        Args:
            container (str): Container name
            src_dir (str): Source directory
            dst_dir (str): Destination directory
            kubectl_args (str): kubectl arguments

        Returns:
            bool: False on OK
        """
        self._verbose('Fetching file list...')
        files_local, files_full_path = \
            _list_local_directory_recursively(src_dir)
        self._verbose(files_local)

        self._verbose('Creating destination directory structure...')
        dst_directories = _summarize_directory_structure(
            _join_paths(dst_dir, files_local))

        for dst_directory in dst_directories:
            cmd = (f'{_kubectl_path()} exec -i {kubectl_args} '
                   f'-c {container} '
                   f'-- sh -c "mkdir -p {dst_directory}"')
            self._verbose(f'  Command: {cmd}')
            try:
                subprocess.run(shlex.split(cmd),
                               check=True, capture_output=True)
            except subprocess.CalledProcessError:
                print('  Failed to create directory')
                return True

        for file_name, src_path in zip(files_local, files_full_path):
            dst_path = os.path.join(dst_dir, file_name)

            if self.from_localhost_to_container(
                    container, src_path, dst_path, kubectl_args):
                return True

        return False

    def __check_remote_path(self, container: str, path: str,
                            kubectl_args: str) -> bool:
        """ Check if remote path exists

        Args:
            container (str): Container name
            path (str): Remote path
            kubectl_args (str): kubectl arguments

        Returns:
            bool: True when path exists
        """
        self._verbose('Checking if remote path exists...')
        cmd = (f'{_kubectl_path()} exec -i {kubectl_args} '
               f'-c {container} '
               f'-- sh -c "[ -f {path} ] || [ -d {path} ]"')
        self._verbose(f'  Command: {cmd}')
        try:
            if subprocess.run(shlex.split(cmd), check=True,
                              capture_output=True).returncode == 0:
                return True
            return False
        except subprocess.CalledProcessError:
            print(f'  Not found: {path}')
            return False


def _detect_direction(src_path, dst_path) -> Direction:
    if len(_split_container_and_file(src_path)) > 1:
        return Direction.download
    if len(_split_container_and_file(dst_path)) > 1:
        return Direction.upload
    return Direction.invalid


def _kubectl_path():
    possible_paths = [
        '/snap/bin/kubectl',
        '/usr/bin/kubectl',
        '/usr/local/bin/kubectl',
    ]
    for path in possible_paths:
        if os.path.isfile(path):
            return path
    sys.exit('kubectl: command not found')


def _create_directory(path: str) -> bool:
    """ Create directory

    Args:
        dst_path (str): Directory name

    Returns:
        bool: False on OK
    """
    try:
        os.mkdir(path)
        return False
    except FileExistsError:
        print(f'    Directory {path} already exists.')
        return True


def _read_file(file_path: str) -> bytes:
    """ Read file content

    Args:
        file_path (str): File path

    Returns:
        bytes: File content
        False: Error (i.e. file not found)
    """
    try:
        with open(file_path, 'rb') as f:
            content = f.read()
        return content
    except FileNotFoundError:
        return False
    except EnvironmentError:
        return False


def _save_file(file_path: str, content: bytes) -> bool:
    """ Save content to file

    Args:
        file_path (str): File path
        content (bytes): Content

    Returns:
        bool: False on OK
    """
    try:
        with open(file_path, 'wb') as f:
            f.write(content)
    except EnvironmentError:
        return True

    return False


def _split_container_and_file(path: str) -> list:
    return path.split(':', 1)


def _list_local_directory_recursively(path: str) \
        -> tuple[list[str], list[str]]:
    """ List local directory recursively

    Args:
        path (str): Work directory

    Returns:
        tuple[list, list]: Lists of files and with full path
    """
    file_names: list[str] = []
    full_paths: list[str] = []

    for dirpath, _, filenames in os.walk(path):
        for f in filenames:
            file_names.append(
                os.path.join(dirpath, f))
            full_paths.append(
                os.path.abspath(os.path.join(dirpath, f)))

    return file_names, full_paths


def _join_paths(base_path: str, files: list[str]) -> list[str]:
    result: list[str] = []
    for i in files:
        result.append(os.path.join(base_path, i))
    return result


def _summarize_directory_structure(files: list[str]) -> set[str]:
    result: list[str] = []
    for i in files:
        result.append(os.path.dirname(i))
    return set(result)


if __name__ == '__main__':
    Main()
